#include <iostream>
namespace CISP430_A3
{
	
	template<class Item>
	sequence<Item>::sequence() 
	{
		// initialize each pointer to NULL. The sequence contains nothing
		// so we have each pointer pointing to nothing.
		head_ptr = NULL;
		tail_ptr = NULL;
		cursor = NULL;
		precursor = NULL;
		// there are no nodes, therefore the node count is zero. 
		many_nodes = 0;

	}
	
	template <class Item>
	sequence<Item>::sequence(const sequence<Item>& source)
	{
		//??? nothing mentioned about this function in the comments?
		// guess i'll do this one later.
	}
	
	template <class Item>
	sequence<Item>::~sequence()
	{
			
	}
	
	template <class Item>
	void sequence<Item>::advance()
	{
		if (is_item()) {
			// when we move one to the right, the precursor goes where to the cursor was, 
			precursor = cursor;
			// and the cursor goes just one after the precursor.
			cursor = precursor->link();
		}
	}
	
	template <class Item>
	void sequence<Item>::start()
	{
		// set the cursor to the very beginning at the head pointer
		cursor = head_ptr;
		// set the precursor to NULL, since there is nothing before the beginning
		precursor = NULL;
	}

	template <class Item>
	void sequence<Item>::insert(const value_type& entry)
	{
		// check to see if the cursor is currently at the head pointer
		// if it is, made a new node pointing to the head node
		// and set it to the new node.
		if (cursor == head_ptr) {
			// put the new node at the head of the linked list.
			list_head_insert(head_ptr, entry);
			// if we have a situation where the tail pointer is null but the head pointer
			// exists, it must be the only node in the list.
			if (tail_ptr == NULL)
			{
				// since it's the first and ONLY node, it is the first and last node.
				// therefore we have the beginning and end pointers point to the same thing
				tail_ptr = head_ptr;
			}
			// we make this the current item of the sequence by pointing the 
			// cursor pointer at the node.
			cursor = head_ptr;
			// and we do nothing to the precursor, since there is nothing before this 
			// pointer, it stays at null.
		}
		else {
			// insert the node just after the precursor.
			// this will give us a new node where the cursor used to be.
			list_insert(precursor, entry);
			// we then set the cursor to the node that the precursor points to. 
			// this is the newly inserted node.
			cursor = precursor->link();
			
		}
	}
	/*
	template <class Item>
	void sequence<Item>::attach(const value_type& entry) 
	{

	}
	*/
}
