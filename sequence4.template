#include <iostream>
namespace CISP430_A3
{
	
	template<class Item>
	sequence<Item>::sequence() 
	{
		// initialize each pointer to NULL. The sequence contains nothing
		// so we have each pointer pointing to nothing.
		head_ptr = NULL;
		tail_ptr = NULL;
		cursor = NULL;
		precursor = NULL;
		// there are no nodes, therefore the node count is zero. 
		many_nodes = 0;

	}
	
	template <class Item>
	sequence<Item>::sequence(const sequence<Item>& source)
	{
		//??? nothing mentioned about this function in the comments?
		// guess i'll do this one later.
	}
	
	template <class Item>
	sequence<Item>::~sequence()
	{
			
	}
	
	template <class Item>
	void sequence<Item>::advance()
	{
		if (is_item()) {
			// when we move one to the right, the precursor goes where to the cursor was, 
			precursor = cursor;
			// and the cursor goes just one after the precursor.
			cursor = precursor->link();
		}
	}
	
	template <class Item>
	void sequence<Item>::start()
	{
		// set the cursor to the very beginning at the head pointer
		cursor = head_ptr;
		// set the precursor to NULL, since there is nothing before the beginning
		precursor = NULL;
	}

	template <class Item>
	void sequence<Item>::insert(const value_type& entry)
	{
		// CASE 1 Empty Linked List
		if (head_ptr == NULL && tail_ptr == NULL)
		{
			list_head_insert(head_ptr, entry);
			tail_ptr = head_ptr;
			// point current pointer at the head pointer, and precursor to null
			start();
			// increment amount nodes.
			many_nodes++;
		} // CASE 2, insertion at head or insertion at NULL (End of list)
		  // either way it is treated as if you inserted a value at the beginning of the list.
		else if (cursor == head_ptr || cursor == NULL)
		{
			list_head_insert(head_ptr, entry);
			// point current pointer at the head pointer, and precursor to null
			start();
			many_nodes++;
		} 		
		else // CASE 3 insertion anywhere in the list. 
		{
			// insert new node after the current precursor.
			list_insert(precursor, entry);
			// set the cursor to point to the node pointed to 
			// by the node pointed at by the precursor.
			cursor = precursor->link();
			many_nodes++;
		}
	}

	template <class Item>
	void sequence<Item>::attach(const value_type& entry)
	{
		// CASE 1: the linked list is empty
		if (head_ptr == NULL && tail_ptr == NULL)
		{
			// populate it with a node containing the entry.
			list_head_insert(head_ptr, entry);
			tail_ptr = head_ptr;
			// point current pointer at the head pointer, and precursor to null
			start();
			// increment amount nodes.
			many_nodes++;
		} // CASE 2: Cursor is at the end or has gone beyond the end.
		else if (cursor == tail_ptr || cursor == NULL)
		{
			// insert new node just after the tail pointer
			list_insert(tail_ptr, entry);
			// set the precursor to the current tail pointer (The second to last node in
			// the sequence)
			precursor = tail_ptr;
			// set the tail pointer point to the new node, since it is the new node.
			tail_ptr = tail_ptr->link();
			// move the current pointer to the newly made end node.
			cursor = tail_ptr;
			//increment amount of nodes by 1. 
			many_nodes++;
		} // CASE 3: attaching to any node
		else
		{
			// instead of using the precursor here, we use the cursor, since we want
			// to insert a new node after the current node
			list_insert(cursor, entry);
			// set the precursor to the cursor, since the new cursor will pointed to the 
			// one after it is currently pointed
			precursor = cursor;
			// then set the current to newly created node
			cursor = cursor->link();
			// increment the amount of nodes by 1
			many_nodes++;
		}
	}
}